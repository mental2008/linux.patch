diff -uprN linux-5.5.5-old/arch/x86/entry/syscalls/syscall_64.tbl linux-5.5.5-new/arch/x86/entry/syscalls/syscall_64.tbl
--- linux-5.5.5-old/arch/x86/entry/syscalls/syscall_64.tbl	2020-02-19 10:54:14.000000000 -0800
+++ linux-5.5.5-new/arch/x86/entry/syscalls/syscall_64.tbl	2020-02-24 07:06:16.136225977 -0800
@@ -343,6 +343,7 @@
 332	common	statx			__x64_sys_statx
 333	common	io_pgetevents		__x64_sys_io_pgetevents
 334	common	rseq			__x64_sys_rseq
+335	64	print_pid_info		__x64_sys_print_pid_info
 # don't use numbers 387 through 423, add new calls after the last
 # 'common' entry
 424	common	pidfd_send_signal	__x64_sys_pidfd_send_signal
diff -uprN linux-5.5.5-old/include/linux/syscalls.h linux-5.5.5-new/include/linux/syscalls.h
--- linux-5.5.5-old/include/linux/syscalls.h	2020-02-19 10:54:14.000000000 -0800
+++ linux-5.5.5-new/include/linux/syscalls.h	2020-02-24 07:05:47.099621021 -0800
@@ -1000,6 +1000,7 @@ asmlinkage long sys_fspick(int dfd, cons
 asmlinkage long sys_pidfd_send_signal(int pidfd, int sig,
 				       siginfo_t __user *info,
 				       unsigned int flags);
+asmlinkage long sys_print_pid_info(pid_t, char*, size_t);
 
 /*
  * Architecture-specific system calls
diff -uprN linux-5.5.5-old/kernel/sys.c linux-5.5.5-new/kernel/sys.c
--- linux-5.5.5-old/kernel/sys.c	2020-02-19 10:54:14.000000000 -0800
+++ linux-5.5.5-new/kernel/sys.c	2020-02-24 07:05:13.742927566 -0800
@@ -73,6 +73,19 @@
 
 #include "uid16.h"
 
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/stat.h>
+#include <linux/fcntl.h>
+#include <linux/jiffies.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/dirent.h>
+#include <linux/unistd.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/sched/signal.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
 #endif
@@ -2651,3 +2664,155 @@ COMPAT_SYSCALL_DEFINE1(sysinfo, struct c
 	return 0;
 }
 #endif /* CONFIG_COMPAT */
+
+/*
+* This is my own function of sys_print_pid_info.
+*/
+typedef struct proc_t {
+	int pid, ppid;
+	char status;
+	unsigned long start_time;
+} proc_t;
+
+void stat2proc(const char* S, proc_t *P) {
+	S = strchr(S, ')') + 2;
+	sscanf(S, "%c %d %*d %*d %*d %*d %*u %*u %*u %*u %*u %*u %*u %*u %*u %*d %*d %*d %*d %ld", &P->status, &P->ppid, &P->start_time);
+	return;
+}
+
+void get_pid_info(pid_t pid, proc_t *P) {
+	char path[32], sbuf[1024];
+	struct file *fd;
+	mm_segment_t fs;
+	size_t i;
+
+	sprintf(path, "/proc/%d/stat", pid);
+	fd = filp_open(path, O_RDONLY, 0);
+	if (IS_ERR(fd)) {
+		P->pid = -1;
+		return;	
+	}
+	
+	for (i = 0; i < sizeof(sbuf); ++i) sbuf[i] = '\0';
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	fd->f_op->read(fd, sbuf, sizeof(sbuf), &fd->f_pos);
+	set_fs(fs);
+	filp_close(fd, NULL);
+
+	P->pid = pid;
+	stat2proc(sbuf, P);
+	return;
+}
+
+unsigned long get_proc_time(unsigned long start_time) {
+	struct file *fd;
+	unsigned long boot_time;
+	char sbuf[24];
+	mm_segment_t fs;
+	size_t i;
+	
+	fd = filp_open("/proc/uptime", O_RDONLY, 0);
+	boot_time = 0;
+	if (IS_ERR(fd)) {
+		printk("Failed to open /proc/uptime.\n");
+	}
+	else {
+		printk("Successfully open /proc/uptime.\n");
+		for (i = 0; i < sizeof(sbuf); ++i) sbuf[i] = '\0';
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+		fd->f_op->read(fd, sbuf, sizeof(sbuf), &fd->f_pos);
+		set_fs(fs);		
+		for (i = 0; i < sizeof(sbuf); ++i) {
+			if (sbuf[i] >= '0' && sbuf[i] <= '9') boot_time = boot_time * 10 + (sbuf[i] - '0');
+			else break;
+		}
+	}
+	filp_close(fd, NULL);
+
+	printk("Boot_time: %ld, start_time: %ld, HZ: %d.\n", boot_time, start_time, HZ);
+	return boot_time - (start_time)/HZ;
+}
+
+long print_pid_info_offset(pid_t pid, char *buffer, size_t *size, size_t *offset) {
+	proc_t *p, *temp;
+	int sid;
+	unsigned long son_start_time;
+	unsigned long running_time;
+	int cid;
+	struct task_struct *task;
+	char sbuf[24];
+	int result;
+	long status;
+	size_t i;
+
+	p = (struct proc_t*)kmalloc(sizeof(struct proc_t), GFP_KERNEL);
+	get_pid_info(pid, p);
+	if (p->pid == -1) {
+		printk("Couldn't know the status of given process %d, please check if exists.\n", pid);
+		return -1;
+	}
+	
+	sid = -1;
+	son_start_time = 0;
+	for_each_process(task) {	
+		cid = task->pid;
+		temp = (struct proc_t*)kmalloc(sizeof(struct proc_t), GFP_KERNEL);
+		get_pid_info(cid, temp);
+		if (temp->ppid == pid) {
+			if (sid == -1 || son_start_time > temp->start_time) {
+				sid = cid;
+				son_start_time = temp->start_time;
+			}
+		}
+	}
+
+	running_time = get_proc_time(p->start_time);
+	printk("Given process: %d, status: %c, running time: %lds\n", pid, p->status, running_time);
+	printk("PID of parent process: %d\n", p->ppid);
+	if (sid == -1)
+		printk("There doesn't exist any child process of given process %d.\n", pid);
+	else
+		printk("PID of the first child process: %d\n", sid);
+	if ((*size) < 24) {
+		printk("Not enough space in buffer.\n");
+		return -1;	
+	}
+	
+	for (i = 0; i < sizeof(sbuf); ++i) sbuf[i] = '\0';
+	sprintf(sbuf, "%d %c %ld %d %d\n", pid, p->status, running_time, p->ppid, sid);
+	result = copy_to_user(buffer + (*offset), sbuf, (unsigned long)sizeof(sbuf));
+	if (result == 0) {
+		printk("Successfully get the information of given process %d in buffer.\n", pid);
+		*size = (*size) - 24;
+		*offset = (*offset) + 24;	
+	}	
+	else {
+		printk("Failed to get the information of given process %d in buffer.\n", pid);
+		return -1;	
+	}
+
+	for_each_process(task) {
+		cid = task->pid;
+		temp = (struct proc_t*)kmalloc(sizeof(struct proc_t), GFP_KERNEL);
+		get_pid_info(cid, temp);
+		if (temp->ppid == pid) {
+			status = print_pid_info_offset(cid, buffer, size, offset);
+			if (status == -1)
+				return status;
+		}
+	} // iterate
+
+	return 0;
+}
+
+SYSCALL_DEFINE3(print_pid_info, pid_t, pid, char*, buffer, size_t, size) {
+	size_t offset, sz;
+	
+	printk("PRINT_pid_info: This is new system call to print out the information about descendant processes of given process %d.\n", pid);
+	offset = 0;
+	sz = size;	
+	
+	return print_pid_info_offset(pid, buffer, &sz, &offset);
+}
